// File: main.v
// Generated by MyHDL 1.0dev
// Date: Sun Oct 18 14:42:50 2015


`timescale 1ns/10ps

module main (
    inclk,
    dclk,
    A,
    B,
    C,
    D,
    R1,
    B1,
    G1,
    R2,
    B2,
    G2,
    latch,
    OE,
    mosi,
    sclk,
	 rst
);


input inclk;
output dclk;
wire dclk;
output A;
reg A;
output B;
reg B;
output C;
reg C;
output D;
reg D;
output R1;
reg R1;
output B1;
reg B1;
output G1;
reg G1;
output R2;
reg R2;
output B2;
reg B2;
output G2;
reg G2;
output latch;
reg latch;
output OE;
wire OE;
input mosi;
input sclk;
input rst;

reg clk;
reg [47:0] img[1023:0];
reg [5:0] d_next_col;
reg [3:0] d_next_row;
reg [5:0] d_which_col;
reg [3:0] d_which_row;
//reg [65535:0] d_cur_img;
reg d_do_latch;
reg [7:0] d_pwm_ctr;
reg [47:0] nextColors;


reg [9:0] spi_idx_major;
reg [5:0] spi_idx_minor;

initial spi_idx_minor <= 0;
initial spi_idx_major <= 0;
initial nextColors <= 0;

reg [47:0] spibuf;

always @(posedge sclk or negedge rst) begin: MAIN_RS_RX
    if (rst == 0) begin
        spi_idx_minor <= 0;
        spi_idx_major <= 0;
    end else begin
        if (spi_idx_minor >= 47) begin
            img[spi_idx_major] <= {mosi, spibuf[46:0]};
            spi_idx_major <= spi_idx_major + 1;
            spi_idx_minor <= 0;
        end else begin
            spibuf[spi_idx_minor] <= mosi;
            spi_idx_minor <= spi_idx_minor+1;
        end
    end
end


always @(posedge inclk) begin: MAIN_DIVIDER_DIVIDE
    reg [22-1:0] count;
    if ((count < (1 - 1))) begin
        count <= (count + 1);
    end
    else begin
        clk <= (!clk);
        count <= 0;
    end
end

always @(posedge clk or negedge rst) begin: MAIN_D_DISP
  if (rst == 0) begin
    d_next_row <= 0;
	 d_next_col <= 0;
	 d_which_row <= 0;
	 d_which_col <= 0;
  end else begin
//    R1 <= nextColors[ 7];
//    G1 <= nextColors[15];
//    B1 <= nextColors[23];
//    R2 <= nextColors[31];
//    G2 <= nextColors[39];
//    B2 <= nextColors[47]; 
    R1 <= nextColors[ 7: 0] > d_pwm_ctr;
    G1 <= nextColors[15: 8] > d_pwm_ctr;
    B1 <= nextColors[23:16] > d_pwm_ctr;
    R2 <= nextColors[31:24] > d_pwm_ctr;
    G2 <= nextColors[39:32] > d_pwm_ctr;
    B2 <= nextColors[47:40] > d_pwm_ctr;

    nextColors <= img[(d_next_row+1) * 64 + d_next_col];
    A <= d_which_row[0];
    B <= d_which_row[1];
    C <= d_which_row[2];
    D <= d_which_row[3];

    latch <= d_which_col == 63;
//    if (d_which_col == 63) begin
//        d_which_col <= 0;
//        //d_do_latch <= 1'b1;
//
//        if ((d_which_row == ((32 / 2) - 1))) begin
//            //d_cur_img <= img;
//            d_which_row <= 0;
//            if ((d_pwm_ctr == (255 - 1))) begin
//                d_pwm_ctr <= 0;
//            end
//            else begin
//                d_pwm_ctr <= (d_pwm_ctr + 1);
//            end
//        end
//        else begin
//            d_which_row <= (d_which_row + 1);
//        end
//    end
//    else begin
//        //d_do_latch <= 1'b0;
//        d_which_col <= (d_which_col + 1);
//    end

    d_which_col <= d_next_col;
	 d_which_row <= d_next_row;
    if (d_next_col == 63) begin
        d_next_col <= 0;

        if (d_next_row == (32/2)-1) begin
        //if (d_which_row == 4) begin
            d_next_row <= 0;
				if ((d_pwm_ctr == (255 - 1))) begin
                d_pwm_ctr <= 0;
            end
            else begin
                d_pwm_ctr <= (d_pwm_ctr + 1);
            end
        end else begin
            d_next_row <= d_next_row + 1;
        end
    end else begin
        d_next_col <= d_next_col + 1;
    end
  end
end


//always @(negedge clk) begin: MAIN_D_CLOSE_LATCH
//    latch <= d_do_latch;
//end



assign dclk = (!clk);
assign OE = 0; // Always enabled

endmodule
